
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traitement des signaux bruités &#8212; Traitement du signal 2</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/jbvinc.css" />
    <link rel="stylesheet" type="text/css" href="_static/.ipynb_checkpoints/jbvinc-checkpoint.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="Exercices : Traitement statistique du signal" href="ssp-t.html" />
    <link rel="prev" title="Bruit dans les signaux" href="bruit.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      <h1 class="site-logo" id="site-title">Traitement du signal 2</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Rechercher dans ce livre ..." aria-label="Rechercher dans ce livre ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="index.html">
   Introduction
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Révisions
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="rev-t.html">
   ✎ Exercices théoriques
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="rev-p.html">
   ✎ Exercices sur machine
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="tp/tp11.html">
     ✐ Représentation d’un signal
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tp/tp12.html">
     ✐ Produit de convolution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tp/tp13.html">
     ✐ Transformée de Fourier discrète
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tp/tp14.html">
     ✐ Analyse spectrale d’un signal audio
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Filtrage
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="filtre-intro.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laplace.html">
   Transformée de Laplace
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="z.html">
   Transformée en Z
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="filtres-analogiques.html">
   Filtres analogiques
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="filtres-numeriques.html">
   Filtres numériques
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="filtres-t.html">
   ✎ Exercices théoriques
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="filtres-p.html">
   ✎ Exercices sur machine
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="tp/tp2.html">
     ✐ Filtrage numérique
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Traitement statistique du signal
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="bruit.html">
   Bruit dans les signaux
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Traitement des signaux bruités
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ssp-t.html">
   ✎ Exercices théoriques
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ssp-p.html">
   ✎ Exercices sur machine
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Annexes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference external" href="https://moodle.unistra.fr/course/view.php?id=5497">
   Moodle
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="python.html">
   Installer et utiliser Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="refs.html">
   Références
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="licence.html">
   Licence
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Basculer la navigation" aria-controls="site-navigation"
                title="Basculer la navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Téléchargez cette page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/traitement-bruit.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Télécharger le fichier source" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Imprimer au format PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Mode plein écran"
        title="Mode plein écran"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contenu
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#detection-de-signaux">
   Détection de signaux
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#detection-de-signaux-periodiques-inconnus-de-periode-inconnue">
     Détection de signaux périodiques inconnus de période inconnue
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#detection-de-signaux-periodiques-inconnus-de-periode-connue">
     Détection de signaux périodiques inconnus de période connue
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#detection-d-un-motif">
     Détection d’un motif
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#debruitage-de-signaux">
   Débruitage de signaux
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#debruitage-d-un-signal-unique">
     Débruitage d’un signal unique
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#debruitage-de-plusieurs-realisations-d-un-meme-signal">
     Débruitage de plusieurs réalisations d’un même signal
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#approximation-par-moindres-carres">
   Approximation par moindres carrés
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#problematique">
     Problématique
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ecriture-matricielle">
     Écriture matricielle
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#minimisation-du-critere-des-moindres-carres">
     Minimisation du critère des moindres carrés
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#illustration">
     Illustration
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="traitement-des-signaux-bruites">
<span id="c-ssp-traitement"></span><h1>Traitement des signaux bruités<a class="headerlink" href="#traitement-des-signaux-bruites" title="Lien permanent vers ce titre">¶</a></h1>
<p>Nous présentons différentes techniques de traitement de signaux bruités.
Ces techniques sont regroupées en trois parties :</p>
<ul class="simple">
<li><p>la détection de signal, c’est-à-dire déterminer si un signal particulier est présent dans des données bruitées,</p></li>
<li><p>le débruitage, c’est-à-dire réduire le plus possible le bruit présent dans un signal,</p></li>
<li><p>l’approximation, c’est-à-dire estimer le signal sous-jacent dans des données bruitées.</p></li>
</ul>
<p>Sauf indication contraire, nous supposons que le bruit est blanc, gaussien et additif :
par conséquent, le signal observé <span class="math notranslate nohighlight">\(y\)</span> est la somme d’un signal non bruité <span class="math notranslate nohighlight">\(x\)</span> et d’un bruit <span class="math notranslate nohighlight">\(b\)</span>.</p>
<div class="section" id="detection-de-signaux">
<h2>Détection de signaux<a class="headerlink" href="#detection-de-signaux" title="Lien permanent vers ce titre">¶</a></h2>
<p>Lorsque l’on parle de « détecter un signal », cela signifie répondre à la question : « le signal <span class="math notranslate nohighlight">\(x\)</span> est-il présent dans le signal observé <span class="math notranslate nohighlight">\(y\)</span> ? ».
Différentes techniques de détection existent, en fonction des connaissances que l’on a sur le signal recherché <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="section" id="detection-de-signaux-periodiques-inconnus-de-periode-inconnue">
<h3>Détection de signaux périodiques inconnus de période inconnue<a class="headerlink" href="#detection-de-signaux-periodiques-inconnus-de-periode-inconnue" title="Lien permanent vers ce titre">¶</a></h3>
<p>Dans le cas où l’on cherche dans l’observation un signal <span class="math notranslate nohighlight">\(x\)</span> périodique, mais qu’on ne connait ni sa période ni sa forme,
alors l’autocorrélation de <span class="math notranslate nohighlight">\(y\)</span> permet de déterminer si le signal <span class="math notranslate nohighlight">\(x\)</span> est présent et quelle est sa période.
On rappelle que l”<a class="reference external" href="https://vincmazet.github.io/signal1/xcorr/intercorrelation.html#autocorrelation">autocorrélation</a>
correspond à mesurer la ressemblance d’un signal avec une version plus ou moins décalée de lui-même.</p>
<p>L’autocorrélation de l’observation <span class="math notranslate nohighlight">\(y = x + b\)</span> est :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
R_y[m] &amp;= \sum_{n=-\infty}^{+\infty} y[n+m] y[n] \\
       &amp;= \sum_{n=-\infty}^{+\infty} (x[n+m]+b[n+m]) (x[n]+b[n]) \\
       &amp;= R_{x}[m] + R_{xb}[m] + R_{bx}[m] + R_{b}[m]
\end{split}\]</div>
<p>où :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(R_{x}\)</span> est l’autocorrélation de <span class="math notranslate nohighlight">\(x\)</span>, elle est périodique de même période que <span class="math notranslate nohighlight">\(x\)</span> ;</p></li>
<li><p><span class="math notranslate nohighlight">\(R_{xb}\)</span> et <span class="math notranslate nohighlight">\(R_{bx}\)</span> sont les intercorrélations entre <span class="math notranslate nohighlight">\(x\)</span> et <span class="math notranslate nohighlight">\(b\)</span> ; elles sont nulles puisque les deux signaux sont décorrélés ;</p></li>
<li><p><span class="math notranslate nohighlight">\(R_{b}\)</span> est l’autocorrélation du bruit <span class="math notranslate nohighlight">\(b\)</span> et elle est nulle (sauf en zéro) puisque le bruit est blanc (ses échantillons sont décorrélés).</p></li>
</ul>
<p>Finalement, l’autocorrélation <span class="math notranslate nohighlight">\(R_y\)</span> est égale à l’autocorrélation de <span class="math notranslate nohighlight">\(x\)</span> (sauf en zéro).
Si <span class="math notranslate nohighlight">\(x\)</span> est bien présent dans l’observation, alors <span class="math notranslate nohighlight">\(R_y\)</span> est périodique et sa période est égale à la période de <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="figure align-default" id="f-ssp-detection1">
<img alt="_images/detection1.svg" src="_images/detection1.svg" /><p class="caption"><span class="caption-number">Fig. 25 </span><span class="caption-text">Le signal <span class="math notranslate nohighlight">\(y\)</span> est la somme du signal <span class="math notranslate nohighlight">\(x\)</span> (périodique, mais de forme et de période inconnues) et d’un bruit blanc <span class="math notranslate nohighlight">\(b\)</span>.
L’autocorrélation <span class="math notranslate nohighlight">\(R_{y}\)</span> fait apparaître un motif périodique de période 50
qui confirme la présence dans <span class="math notranslate nohighlight">\(y\)</span> d’un signal de même période.</span><a class="headerlink" href="#f-ssp-detection1" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
<div class="section" id="detection-de-signaux-periodiques-inconnus-de-periode-connue">
<h3>Détection de signaux périodiques inconnus de période connue<a class="headerlink" href="#detection-de-signaux-periodiques-inconnus-de-periode-connue" title="Lien permanent vers ce titre">¶</a></h3>
<p>Ce cas est plus favorable que le précédent car on dispose d’une information supplémentaire.
On cherche à déterminer si l’observation <span class="math notranslate nohighlight">\(y\)</span> correspond au signal périodique <span class="math notranslate nohighlight">\(x\)</span> (de période <span class="math notranslate nohighlight">\(T\)</span>) bruité par un bruit blanc <span class="math notranslate nohighlight">\(b\)</span>.
Le principe de détection consiste à effectuer l’intercorrélation de <span class="math notranslate nohighlight">\(y\)</span> avec un signal auxiliaire <span class="math notranslate nohighlight">\(z\)</span> périodique et de période <span class="math notranslate nohighlight">\(T\)</span>
(par exemple une simple sinusoïde).</p>
<p>En effet, l’intercorrélation de  <span class="math notranslate nohighlight">\(y\)</span> et <span class="math notranslate nohighlight">\(z\)</span> est égale à :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
R_{yz}[m] &amp;= \sum_{n=-\infty}^{+\infty} y[n+m] z[n] \\
       &amp;= \sum_{n=-\infty}^{+\infty} (x[n+m]+b[n+m]) z[n] \\
       &amp;= R_{xz}[m] + R_{bz}[m].
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(R_{xz}\)</span> est périodique puisque <span class="math notranslate nohighlight">\(x\)</span> et <span class="math notranslate nohighlight">\(z\)</span> sont de même période,
alors que <span class="math notranslate nohighlight">\(R_{bz}\)</span> est nulle puisque <span class="math notranslate nohighlight">\(b\)</span> et <span class="math notranslate nohighlight">\(z\)</span> sont décorrélés.
Ainsi, <span class="math notranslate nohighlight">\(R_{yz}\)</span> sera périodique de période <span class="math notranslate nohighlight">\(T\)</span> si le signal <span class="math notranslate nohighlight">\(x\)</span> est présent.</p>
<div class="figure align-default" id="f-ssp-detection2">
<img alt="_images/detection2.svg" src="_images/detection2.svg" /><p class="caption"><span class="caption-number">Fig. 26 </span><span class="caption-text">Le signal observé <span class="math notranslate nohighlight">\(y\)</span> est la somme du signal périodique <span class="math notranslate nohighlight">\(x\)</span> (de forme inconnue mais de période connue) et d’un bruit blanc <span class="math notranslate nohighlight">\(b\)</span>.
Le signal auxiliaire <span class="math notranslate nohighlight">\(z\)</span> est ici une sinusoïde de même période que <span class="math notranslate nohighlight">\(x\)</span>.
L’intercorrélation <span class="math notranslate nohighlight">\(R_{yz}\)</span> fait apparaître un motif périodique de période 50
qui confirme la présence dans <span class="math notranslate nohighlight">\(y\)</span> d’un signal de même période.</span><a class="headerlink" href="#f-ssp-detection2" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
<div class="section" id="detection-d-un-motif">
<h3>Détection d’un motif<a class="headerlink" href="#detection-d-un-motif" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un « motif » est un signal déterministe connu et de durée finie.
La technique suivante permet de déterminer si le motif est présent dans l’observation <span class="math notranslate nohighlight">\(y\)</span>,
et si oui à obtenir son instant d’apparition.
L’observation est donc modélisée :</p>
<div class="math notranslate nohighlight">
\[
y[n] = x[n-k] + b[n]
\]</div>
<p>où <span class="math notranslate nohighlight">\(k\)</span> est l’instant d’apparition du motif <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>On peut déterminer l’instant <span class="math notranslate nohighlight">\(k\)</span> où le motif apparaît en calculant l’intercorrélation entre <span class="math notranslate nohighlight">\(y\)</span> et <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Comme l’intercorrélation entre <span class="math notranslate nohighlight">\(y\)</span> et <span class="math notranslate nohighlight">\(x\)</span> est équivalente à la convolution entre <span class="math notranslate nohighlight">\(y\)</span> et le motif <span class="math notranslate nohighlight">\(x\)</span> retourné dans le temps (<span class="math notranslate nohighlight">\(x[-n]\)</span>),
cette technique est un filtrage, qu’on appelle « filtrage adapté » (<em>matched filter</em>).
On peut montrer qu’elle est la solution optimale pour maximiser le RSB dans le cadre d’un bruit additif.
Elle est notamment utilisé dans des applications radar ou en communications numériques.</p>
<div class="figure align-default" id="f-ssp-filtre-adapte">
<img alt="_images/filtre-adapte.svg" src="_images/filtre-adapte.svg" /><p class="caption"><span class="caption-number">Fig. 27 </span><span class="caption-text">Le motif <span class="math notranslate nohighlight">\(x\)</span> est une porte et le signal observé <span class="math notranslate nohighlight">\(y\)</span> correspond à <span class="math notranslate nohighlight">\(x\)</span> décalé de <span class="math notranslate nohighlight">\(k=60\)</span> échantillons
et bruité par un bruit blanc gaussien de RSB 20 dB.
Seules les corrélations de <span class="math notranslate nohighlight">\(x\)</span> avec <span class="math notranslate nohighlight">\(x\)</span> et <span class="math notranslate nohighlight">\(y\)</span> présentent un maximum clair,
ce qui indique la présence du motif à cet instant.</span><a class="headerlink" href="#f-ssp-filtre-adapte" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="debruitage-de-signaux">
<h2>Débruitage de signaux<a class="headerlink" href="#debruitage-de-signaux" title="Lien permanent vers ce titre">¶</a></h2>
<p>Débruiter un signal, c’est réduire le plus possible le bruit présent dans le signal.
Sauf cas très particulier, il n’est pas possible d’éliminer complètement le bruit puisqu’il est inconnu.</p>
<div class="section" id="debruitage-d-un-signal-unique">
<h3>Débruitage d’un signal unique<a class="headerlink" href="#debruitage-d-un-signal-unique" title="Lien permanent vers ce titre">¶</a></h3>
<p>On observe un signal <span class="math notranslate nohighlight">\(x\)</span> bruité par un bruit blanc gaussien additif :</p>
<div class="math notranslate nohighlight">
\[
\forall n, \quad y[n] = x[n] + b[n].
\]</div>
<p>Pour réduire le bruit dans le signal, on peut remplacer chaque échantillon <span class="math notranslate nohighlight">\(y[n]\)</span>
par la moyenne des <span class="math notranslate nohighlight">\(M\)</span> échantillons autour de <span class="math notranslate nohighlight">\(n\)</span>.
On obtient alors un nouveau signal <span class="math notranslate nohighlight">\(z\)</span> :</p>
<div class="math notranslate nohighlight">
\[
\forall n, \quad z[n] = \frac{1}{M} \sum_{m=n-\frac{M-1}{2}}^{n+\frac{M-1}{2}} y[m]
\]</div>
<p>où <span class="math notranslate nohighlight">\(M\)</span> est impair.</p>
<div class="example">
<p>Si le signal observé est :</p>
<div class="math notranslate nohighlight">
\[
y = [4,\, 9,\, 8,\, 7,\, 12,\, 5,\, 1,\, 0,\, 5,\, 4,\, 3,\, 2,\, 4]
\]</div>
<p>alors le calcul de la moyenne de <span class="math notranslate nohighlight">\(M=3\)</span> échantillons autour de chaque échantillons de <span class="math notranslate nohighlight">\(y\)</span> donne :</p>
<div class="math notranslate nohighlight">
\[
z = [?,\, 7,\, 8,\, 9,\, 8,\, 6,\, 2,\, 2,\, 3,\, 4,\, 3,\, 3,\, ?]
\]</div>
<p>où les deux points d’interrogation correspondent à des échantillons qu’on ne peut pas calculer.</p>
<p>La <a class="reference internal" href="#f-ssp-filtre-moyenneur-exemple"><span class="std std-numref">Fig. 28</span></a> représente ces deux signaux.</p>
<div class="figure align-default" id="f-ssp-filtre-moyenneur-exemple">
<a class="reference internal image-reference" href="_images/filtre-moyenneur-exemple.svg"><img alt="_images/filtre-moyenneur-exemple.svg" src="_images/filtre-moyenneur-exemple.svg" width="600px" /></a>
<p class="caption"><span class="caption-number">Fig. 28 </span><span class="caption-text">Signaux <span class="math notranslate nohighlight">\(y\)</span> (en bleu) et <span class="math notranslate nohighlight">\(z\)</span> (en orange).</span><a class="headerlink" href="#f-ssp-filtre-moyenneur-exemple" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
<p>On peut montrer que cette technique peut s’écrire sous la forme d’une convolution :
c’est donc un filtrage appelé « filtre moyenneur ».
La réponse impulsionnelle de ce filtre est une porte de longueur <span class="math notranslate nohighlight">\(M\)</span>,
dont la transformée de Fourier à temps discret est un sinus cardinal.
Ainsi, le filtre moyenneur est un filtre passe-bas.
Il atténue les fréquences élevées présentes dans le bruit.</p>
<p>Le filtre moyenneur effectue une moyenne glissante pour remplacer chaque échantillon du signal observé
par la moyenne des <span class="math notranslate nohighlight">\(M\)</span> échantillons voisins.
Comme on l’observe sur la <a class="reference internal" href="#f-ssp-filtre-moyenneur"><span class="std std-numref">Fig. 29</span></a>,
plus le nombre d’échantillons moyennés <span class="math notranslate nohighlight">\(M\)</span> est grand, plus le bruit sera atténué.
Mais la forme du signal d’intérêt <span class="math notranslate nohighlight">\(x\)</span> sera lissée.</p>
<div class="figure align-default" id="f-ssp-filtre-moyenneur">
<img alt="_images/filtre-moyenneur.svg" src="_images/filtre-moyenneur.svg" /><p class="caption"><span class="caption-number">Fig. 29 </span><span class="caption-text">Application d’un filtre moyenneur sur le signal observé <span class="math notranslate nohighlight">\(y\)</span> (qui est la somme du signal d’intérêt <span class="math notranslate nohighlight">\(x\)</span> et d’un bruit).</span><a class="headerlink" href="#f-ssp-filtre-moyenneur" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>Le filtre moyenneur est une très bonne première approche pour débruiter un signal.
Elle reste néanmoins limitée (parce qu’elle a tendance à lisser le signal lui-même),
et il faut parfois recourir à des techniques plus évoluées.</p>
</div>
<div class="section" id="debruitage-de-plusieurs-realisations-d-un-meme-signal">
<h3>Débruitage de plusieurs réalisations d’un même signal<a class="headerlink" href="#debruitage-de-plusieurs-realisations-d-un-meme-signal" title="Lien permanent vers ce titre">¶</a></h3>
<p>Dans le cas où l’on dispose de <span class="math notranslate nohighlight">\(I\)</span> mesures d’un même signal <span class="math notranslate nohighlight">\(x\)</span> :</p>
<div class="math notranslate nohighlight">
\[
\forall i, n, \quad y_i[n] = x[n] + b_i[n]
\]</div>
<p>et que le bruit est centré (<span class="math notranslate nohighlight">\(\mathbb{E}[b_i]=0\)</span>), alors la moyenne des <span class="math notranslate nohighlight">\(y_i\)</span> permet d’augmenter le RSB d’un facteur <span class="math notranslate nohighlight">\(10\log(I)\)</span>.
Aussi, plus il y a de signaux moyennés, meilleur sera le débruitage.</p>
<div class="figure align-default" id="f-ssp-moyennage">
<img alt="_images/moyennage.svg" src="_images/moyennage.svg" /><p class="caption"><span class="caption-number">Fig. 30 </span><span class="caption-text">Moyennage de plusieurs réalisations <span class="math notranslate nohighlight">\(y_i\)</span> d’un même signal <span class="math notranslate nohighlight">\(x\)</span>.
Le premier graphe ci-dessous représente 50 réalisations superposées (en gris),
l’une d’elle est en bleu pour être visible.</span><a class="headerlink" href="#f-ssp-moyennage" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>En photographie, le moyennage de plusieurs images d’une même scène permet de réduire le bruit présent dans la photographie.
En astronomie par exemple, il n’est pas rare de produire des images qui sont le moyennage de plusieurs dizaines d’observations,
elle-même acquises avec un temps de pose très long (plusieurs dizaines de minutes).</p>
</div>
</div>
<div class="section" id="approximation-par-moindres-carres">
<h2>Approximation par moindres carrés<a class="headerlink" href="#approximation-par-moindres-carres" title="Lien permanent vers ce titre">¶</a></h2>
<p>La méthode des moindres carrés (<em>least squares method</em>) a été proposée par Gauss et Legendre à la fin du XVII<sup>e</sup> siècle.
Dans le cadre de l’approximation, elle permet de décrire un signal bruité par un modèle mathématique.</p>
<div class="section" id="problematique">
<h3>Problématique<a class="headerlink" href="#problematique" title="Lien permanent vers ce titre">¶</a></h3>
<p>On considère donc le cas où les observations <span class="math notranslate nohighlight">\(y\)</span> sont la somme d’un signal <span class="math notranslate nohighlight">\(x=f_{\theta}\)</span> bruité :</p>
<div class="math notranslate nohighlight">
\[
\forall n, \quad y[n] = f_{\theta}[n] + b[n]
\]</div>
<p>où :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f_{\theta}\)</span> est une fonction paramétrique (sinusoïde, polynôme, etc.) connue,</p></li>
<li><p><span class="math notranslate nohighlight">\(\theta\)</span> est un ensemble de paramètres <span class="math notranslate nohighlight">\(\theta_0, \theta_1, \dots, \theta_M\)</span> inconnus,</p></li>
<li><p><span class="math notranslate nohighlight">\(f_{\theta}[n]\)</span> est la valeur de la fonction <span class="math notranslate nohighlight">\(f_{\theta}\)</span> en <span class="math notranslate nohighlight">\(n\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(b\)</span> est un bruit de moyenne nulle.</p></li>
</ul>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Si <span class="math notranslate nohighlight">\(f\)</span> n’est pas linéaire, alors il faut utiliser une méthode de moindres carrés non linéaires.</p>
</div>
<p>De manière générale, <span class="math notranslate nohighlight">\(f\)</span> peut être n’importe quelle fonction paramétrée,
comme un polynôme d’ordre 2 (<span class="math notranslate nohighlight">\(f_{\theta}[n] = \theta_0 + \theta_1 n + \theta_2 n^2\)</span>)
ou une exponentielle (<span class="math notranslate nohighlight">\(f_{\theta}[n] = \theta_0 \exp(\theta_1 n)\)</span>).
Mais par simplicité, nous nous concentrons dans cette section sur les fonctions <span class="math notranslate nohighlight">\(f_{\theta}\)</span> linéaires en <span class="math notranslate nohighlight">\(\theta\)</span>,
c’est-à-dire que <span class="math notranslate nohighlight">\(f\)</span> est un polynôme :</p>
<div class="math notranslate nohighlight">
\[
\forall n, \quad f_{\theta}[n] = \theta_0 + \theta_1 n + \theta_2 n^2 + \dots + \theta_M n^M.
\]</div>
</div>
<div class="section" id="ecriture-matricielle">
<h3>Écriture matricielle<a class="headerlink" href="#ecriture-matricielle" title="Lien permanent vers ce titre">¶</a></h3>
<p>Dans la suite, les calculs sont effectués avec la représentation vectorielle.
Les abscisses des échantillons sont regroupés dans le vecteur <span class="math notranslate nohighlight">\(n = \begin{bmatrix} n_1 &amp; \dots &amp; n_N \end{bmatrix}^T\)</span>.
Puisque d’après l’équation précédente :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{cases}
f_{\theta}[n_1] = \theta_0 + \theta_1 n_1 + \theta_2 n_1^2 + \dots + \theta_M n_1^M \\
\quad\dots \\
f_{\theta}[n_N] = \theta_0 + \theta_1 n_N + \theta_2 n_N^2 + \dots + \theta_M n_N^M
\end{cases}
\end{split}\]</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Pour identifier les variables maricielles, on a l’habitude de les écrire en gras.</p>
</div>
<p>alors l’équation du modèle s’écrit simplement sous forme matricielle :</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{y} = \boldsymbol{H} \boldsymbol{\theta} + \boldsymbol{b}
\]</div>
<p>où :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{y} = \begin{bmatrix} y_1 \\ \vdots \\ y_N \end{bmatrix},
\qquad
\boldsymbol{H} = \begin{bmatrix} 1 &amp; n_1 &amp; \dots &amp; n_1^M \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ 1 &amp; n_N &amp; \dots &amp; n_N^M \end{bmatrix},
\qquad
\boldsymbol{\theta} = \begin{bmatrix} \theta_0 \\ \vdots \\ \theta_M \end{bmatrix}
\qquad\text{et}\qquad
\boldsymbol{b} = \begin{bmatrix} b_1 \\ \vdots \\ b_N \end{bmatrix}
\end{split}\]</div>
</div>
<div class="section" id="minimisation-du-critere-des-moindres-carres">
<h3>Minimisation du critère des moindres carrés<a class="headerlink" href="#minimisation-du-critere-des-moindres-carres" title="Lien permanent vers ce titre">¶</a></h3>
<p>L’objectif est de retrouver <span class="math notranslate nohighlight">\(\theta\)</span> à partir de <span class="math notranslate nohighlight">\(y\)</span>.
Il est logique de choisir <span class="math notranslate nohighlight">\(\theta\)</span> comme le paramètre qui minimise les différences entre <span class="math notranslate nohighlight">\(y\)</span> et <span class="math notranslate nohighlight">\(f_\theta\)</span>.
Mathématiquement, il faut donc minimiser</p>
<div class="math notranslate nohighlight">
\[
\mathcal{J} = \sum_{n=1}^N \left(y[n] - f_{\theta}[n]\right)^2.
\]</div>
<p>La parenthèse, qui exprime la différence entre <span class="math notranslate nohighlight">\(y\)</span> et <span class="math notranslate nohighlight">\(f_{\theta}\)</span> en chaque échantillon <span class="math notranslate nohighlight">\(n\)</span>,
est mise au carré car les calculs sont plus simples à effectuer qu’avec une valeur absolue.
On cherche donc à minimiser les différences au carrés, d’où le nom de la méthode.
Remarquez que <span class="math notranslate nohighlight">\(\mathcal{J}\)</span> est le carré de la norme du signal <span class="math notranslate nohighlight">\(y - f_{\theta}\)</span> :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathcal{J}
&amp;= \| \boldsymbol{y} - \boldsymbol{H}\boldsymbol{\theta} \|^2 \\
&amp;= (\boldsymbol{y} - \boldsymbol{H}\boldsymbol{\theta})^T (\boldsymbol{y} - \boldsymbol{H}\boldsymbol{\theta}) \\
&amp;= \boldsymbol{y}^T\boldsymbol{y}
 - \boldsymbol{y}^T\boldsymbol{H}\boldsymbol{\theta}
 - \boldsymbol{\theta}^T\boldsymbol{H}^T\boldsymbol{y}
 + \boldsymbol{\theta}^T\boldsymbol{H}^T\boldsymbol{H}\boldsymbol{\theta}
\end{split}\]</div>
<p>Trouver la valeur de <span class="math notranslate nohighlight">\(\theta\)</span> qui minimise <span class="math notranslate nohighlight">\(\mathcal{J}\)</span> revient à trouver la valeur qui annule la dérivée de <span class="math notranslate nohighlight">\(\mathcal{J}\)</span>,
et on peut montrer que :</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \mathcal{J}}{\partial \boldsymbol{\theta}} = - 2\boldsymbol{H}^T\boldsymbol{y} + 2\boldsymbol{H}^T\boldsymbol{H}\boldsymbol{\theta}
\]</div>
<p>Et donc :</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \mathcal{J}}{\partial \boldsymbol{\theta}} = 0
\qquad\Leftrightarrow\qquad
2\boldsymbol{H}^T\boldsymbol{y} = 2\boldsymbol{H}^T\boldsymbol{H}\boldsymbol{\theta}
\qquad\Leftrightarrow\qquad
\boldsymbol{\theta} = (\boldsymbol{H}^T\boldsymbol{H})^{-1} \boldsymbol{H}^T\boldsymbol{y}.
\]</div>
<p>Cette dernière équation définit donc la valeur de <span class="math notranslate nohighlight">\(\theta\)</span> qui minimise l’erreur des moindres carrés,
c’est donc la valeur de <span class="math notranslate nohighlight">\(\theta\)</span> qui permet d’avoir une fonction <span class="math notranslate nohighlight">\(f_{\theta}\)</span> qui approxime au mieux les données <span class="math notranslate nohighlight">\(y\)</span>.</p>
</div>
<div class="section" id="illustration">
<h3>Illustration<a class="headerlink" href="#illustration" title="Lien permanent vers ce titre">¶</a></h3>
<p>Sur l’exemple de la <a class="reference internal" href="#f-ssp-moindres-carres"><span class="std std-numref">Fig. 31</span></a>, l’observation <span class="math notranslate nohighlight">\(y\)</span> est une version bruitée d’un polynôme <span class="math notranslate nohighlight">\(x\)</span>.
L’approximation par moindres carrés est plus appréciable que celle obtenue avec le filtre moyenneur
car on bénéficie ici du fait que le signal inconnu est un polynôme.</p>
<div class="figure align-default" id="f-ssp-moindres-carres">
<img alt="_images/moindres-carres.svg" src="_images/moindres-carres.svg" /><p class="caption"><span class="caption-number">Fig. 31 </span><span class="caption-text">Les données <span class="math notranslate nohighlight">\(y\)</span> sont approximées par un polynôme d’ordre 3 avec la méthode des moindres carrés.
Le résultat est comparé avec un filtre moyenneur de taille 20, qui donne une estimation moins « propre ».</span><a class="headerlink" href="#f-ssp-moindres-carres" title="Lien permanent vers cette image">¶</a></p>
</div>
<p>La solution obtenue est issue de calcul <span class="math notranslate nohighlight">\(\boldsymbol{\theta} = (\boldsymbol{H}^T\boldsymbol{H})^{-1} \boldsymbol{H}^T\boldsymbol{y}\)</span>.
La figure <a class="reference internal" href="#f-ssp-moindres-carres-differences"><span class="std std-numref">Fig. 32</span></a> représente en orange les différences entre l’observation et l’estimation.
C’est la somme de ces différences qui est minimisée par la méthode des moindres carrés.</p>
<div class="figure align-default" id="f-ssp-moindres-carres-differences">
<img alt="_images/moindres-carres-differences.svg" src="_images/moindres-carres-differences.svg" /><p class="caption"><span class="caption-number">Fig. 32 </span><span class="caption-text">Mise en évidence des erreurs à minimiser.</span><a class="headerlink" href="#f-ssp-moindres-carres-differences" title="Lien permanent vers cette image">¶</a></p>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="bruit.html" title="previous page">Bruit dans les signaux</a>
    <a class='right-next' id="next-link" href="ssp-t.html" title="next page">Exercices : Traitement statistique du signal</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          Par Vincent Mazet (University of Strasbourg, France)<br/>
        
            &copy; droits d'auteur 2021-2022.<br/>
          <div class="extra_footer">
            Traitement du signal 2 &mdash; Vincent Mazet (Université de Strasbourg), 2021 &mdash; <a href='licence.html'>CC BY-NC 4.0</a>.
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>